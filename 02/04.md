# 4. CommonJS 모듈

- CommonJS 명세의 두 가지 주요 개념은 다음과 같다.
```
- require는 로컬 파일 시스템으로부터 모듈을 임포트하게 해준다.
- exports와 module.exports는 특별한 변수로서 현재 모듈에서 공개될 기능을 내보낼 떄 사용한다.
```

## 4.1 직접 만드는 모듈 로더

- Node.js의 `require()` 함수의 일부를 모방하여 본다.

```js
function loadModule(filename, module, require) {
    const wrappedSrc = `
        (function (module, exports, require) {
            ${fs.readFileSync(filename, 'utf8')}
        })(module, module.exports, require)
    `
    eval(wrappedSrc)
}
```

- 먼저 모듈의 내용을 로드하고 이를 private 범위로 감싸서 평가하는 함수를 만들었다.

```js
function require(moduleName) {
    console.log(`Require invoked for module: ${moduleName}`)
    const id = require.resolve(moduleName)      // (1)
    if (require.cache[id]) {                    // (2)
        return require.cache[id].exports
    }

    // 모듈 메타데이터
    const module = {                            // (3)
        exports: {},
        id
    }

    // 캐시 업데이트
    require.cache[id] = module                  // (4)

    // 모듈 로드
    loadModule(id, module, require)             // (5)

    // 익스포트 되는 변수 반환
    return module.exports                       // (6)
}
require.cache = {}
require.resolve = (moduleName) => {
    // 모듈명으로 id로 불리는 모듈의 전체 경로를 찾아냄 (resolve)
}
```

- 위 코드는 Node.js.require() 함수의 동작을 모방한 것이다.
    1. 모듈의 전체경로(`id`)를 알아낸다.
    2. 모듈이 이미 로드되었다면 캐시된 모듈을 사용한다.
    3. 아직 로드가 안 된 모듈을 위한 환경을 설정한다.
    4. 최초 로드 후에 `module` 객체를 캐싱한다.
    5. 모듈 소스코드를 읽고 평가한다.
    6. module.exports의 내용을 반환한다.

## 4.2 모듈 정의

```js
// 또 다른 종속성 로드
const dependency = require('./anotherModule')

// private 함수
function log(){
    console.log(`Well done ${dependency.username}`)
}

// 공개적으로 사용하기 위해 익스포트 한 API
module.exports.run = () => {
    log()
}
```

- `module.exports` 변수에 할당하지 않는 이상 비공개가 된다.

## 4.3 module.exports 대 exports

- `exports`가 `module.exports`의 초기 값에 대한 참조다.
- 이 값은 본질적으로 모듈이 로드되기 전에 만들어지는 간단한 객체 리터럴이다.

```js
// 간단한 프로퍼티 추가
exports.hello = () => {
    console.log('Hello')
}
```

```js
// 잘못된 코드: exports를 재할당하면 module.exports를 변경하는 것이 아니다.
exports = () => {
    console.log('hello')
}
```

```js
// 함수, 인스턴스 또는 문자열과 같은 객체 리터럴 이외의 값은 module.exports를 다시 할당해야 한다.
module.exports = () => {
    console.log('hello')
}
```

## 4.4 require 함수는 동기적이다.

- `require` 함수는 동기적이기에 `module.exports`에 대한 할당도 동기적이어야 한다.

```js
// 올바르지 않은 코드
setTimeout(() => {
    module.exports = function () { /*...*/ }
}, 100)
```

- 따라서 모듈을 정의할 때 동기적으로 코드를 사용하도록 제한되어 있다.
- Node.js의 핵심 라이브러리가 비동기 방식에 대한 대안으로 동기식 API를 제공하는 가장 중요한 이유다.

## 4.5 해결(resolving) 알고리즘

- 종속성 지옥(dependency hell)은 종속성들이 서로 공통된 라이브러리에 의존하지만 서로 호환되지 않는 다른 버전을 필요로 할 때 나타나는 상황이다.
- Node.js는 로드되는 위치에 따라 다른 버전의 모듈을 사용하도록 하였다.
- 이 특성의 장점은 패키지 매니저와 `require()` 함수가 사용하는 해결 알고리즘에도 적용된다.
- 해결 알고리즘은 크게 다음 3가지로 나뉜다. (moduleName)
    1. 파일 모듈: `/`로 시작하면 절대 경로로, `./`로 시작하면 상대 경로로 간주한다.
    2. 코어 모듈: `/`, `./`로 시작하지 않으면 코어 모듈 내에서 검색을 시도한다.
    3. 패키지 모듈: `node_modules` 디렉터리에서 일치하는 모듈을 찾는다. 파일 시스템의 루트에 도달할 때까지 디렉터리 트리를 올라가면서 찾는다.
- 파일 및 패키지 모듈의 경우 개별 파일과 디렉터리가 모두 moduleName과 일치할 수 있다.
    - `<moduleName>.js`
    - `<moduleName>/index.js`
    - `<moduleName>/package.json`의 main 속성에 지정된 디렉터리/파일
- 즉 각각 모듈의 `node_modules`를 먼저 찾고 점점 올라가면서 찾는다.

## 4.6 모듈 캐시

- 캐싱은 다음과 같은 기능적인 영향도 있다.
    - 모듈 종속성 내에서 순환을 가질 수 있다.
    - 일정한 패키지 내에서 동일한 모듈이 필요할 때 얼마간은 동일한 인스턴스가 항상 반환되는 걸 보장한다.
- `require.cache`를 통해 접근할 수도 있다.

## 4.7 순환 종속성

```js
// a.js
exports.loaded = false
const b = require('./b')
module.exports = {
    b,
    loaded: true,
}

// b.js
exports.loaded = false
const a = require('./a')
module.exports = {
    a,
    loaded: true,
}
```

```js
const a = require('./a')
const b = require('./b')
console.log('a ->', JSON.stringify(a, null, 2))
console.log('b ->', JSON.stringify(b, null, 2))

/*
a -> {
    "b": {
        "a": {
            "loaded": false
        },
        "loaded": true
    },
    "loaded": true
}
b -> {
    "a": {
        "loaded": false
    },
    "loaded": true
}
*/
```

- 모듈 `b.js`는 온전하지 않는 `a.js`를 바라보게 된다.

-----
[HOME](./index.md)
