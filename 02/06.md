# 6. ESM: ECMAScript 모듈

- ESM과 CommonJS 사이의 가장 큰 차이점은 ES 모듈이 static이란 점이다.
- 즉 임포트는 모든 모듈의 가장 상위 레벨과 제어 흐름 구문의 바깥쪽에 기술된다.

```
// 이렇게 사용하는 건 적합하지 않다
if (condition) {
    import module1 from 'module1'
} else {
    import module2 from 'module2'
}
```

- 정적 임포트는 사용하지 않는 코드 제거(tree shaking)와 같이 코드 최적화를 할 수 있게 종속성 트리의 정적 분석을 가능하게 해준다.

## 6.1 Node.js에서 ESM의 사용

- Node.js에선 모든 .js 파일이 CommonJS 문법을 기본으로 따른다고 생각한다.
- 따라서 ESM 문법은 인터프리터 에러를 낼 것이다.
- 다음과 같이 사용하면 해결할 수 있다.
    - 모듈 파일의 확장자를 .mjs로 한다.
    - 모듈과 가장 근접한 package.json의 type 필드에 module이라 쓴다.

## 6.2 exports와 imports 지정하기(named exports and imports)

- ESM은 export 키워드를 통해 모듈의 기능을 익스포트한다.
- ESM에서는 기본적으로 private이며 export한 개체만 공개된다.

## 6.3 export와 import 기본값 설정하기(Default exports and imports)

- CommonJS의 module.exports처럼 ESM에서는 default export를 사용할 수 있다.
- 모듈 개발자에게 단일 책임 원칙을 권장하고 깔끔한 하나의 인터페이스를 노출할 수 있다.
- 내부적으로는 default라는 이름으로 익스포트되는 것과 동일하다.

## 6.4 혼합된 export(mixed exports)

- export와 default export를 혼합하여 사용할 수 있다.

```js
export default function log(message) {
    console.log(message)
}

export function info(message) {
    log(`info: ${message}`)
}
```

```js
import mylog, { info } from './logger.js'
```

- default export와 export의 차이점은 다음과 같다.
    - 이름을 가진 export는 명확하다. IDE로 하여금 추론할 수 있게 해준다.
    - default export는 모듈에서 가장 핵심적인 한 가지 기능과 연결하는 편리한 방법이다.
    - default export는 특정 상황에서 tree shaking을 어렵게 만든다.
- 명확한 하나의 기능을 사용할 땐 default export, 아닐 땐 export를 사용하길 권장한다.

## 6.5 모듈 식별자

- 모듈 식별자는 import 구문에서 우리가 적재하고 싶은 모듈의 경로를 명시할 때 쓰이는 값이다.
- 경로를 명시하는 방법은 아래와 같다.
    - 상대적 식별자(Relative): `./logger.js` 같은 방식
    - 절대 식별자(Absolute): `file://opt/nodejs/config.js` 같이 직접적인 경로. 이 방법은 ESM에만 해당하여, `/`, `//`로 시작하면 동작하지 않는다.
    - 노출 식별자(Bare): `node_modules` 폴더에서 사용 가능하고 패키지 매니저를 통해 설치된 모듈 또는 Node.js 코어 모듈을 가리킨다.
    - 심층 임포트 식별자(Deep import): `node_modules`에 있는 패키지의 경로.

## 6.6 비동기 임포트

- import 구문은 정적이라 다음 제약이 존재한다.
    - 모듈 식별자는 실행 중에 생성될 수 없다.
    - 모듈의 임포트는 모든 파일의 최상위에 선언되고, 제어 구문 내에 포함될 수 없다.
- 무거운 모듈을 사용하거나 기능의 특정 부분을 사용할 때 비동기 임포트를 사용한다.
    - import() 연산자를 사용한다.

```js
import('./file-name.js')
    .then(() => { /* 처리 */ })
```

## 6.7 모듈 적재 이해하기

### 로딩 단계

- 인터프리터의 목표: 필요한 모든 모듈의 그래프(종속성 그래프)를 만들기.
- Node 인터프리터가 실행되면, JS 파일 형식으로 실행할 코드가 전달된다.
- 파일은 종속성 확인을 위한 진입점이 된다.
- 진입점부터 모든 코드가 탐색될 때까지 import 구문을 깊이 우선 탐색으로 찾는다.
    - 1단계: 생성(또는 파싱) - 모든 import구문을 찾고 모든 모듈의 내용을 적재한다.
    - 2단계: 인스턴스화 - 익스포트된 모든 개체에 대한 참조를 메모리에 유지한다.
    - 3단계: 평가 - 코드를 실행하여 인스턴스화된 모든 개체가 실제 값을 얻을 수 있도록 한다.
- CommonJS는 동적 성질로 인해 종속성 그래프가 탐색하기 전에 모든 파일을 실행한다.
- ESM은 종속성 그래프가 완적해지기 전까지 어떠한 코드도 실행하지 않는다. 따라서 정적이어야 한다.

### 읽기 전용 라이브 바인딩

- ESM 모듈의 기본적 특징 중 하나는 임포트된 모듈이 익스포트된 값에 대해 읽기 전용 라이브 바인딩된다는 것이다.

```js
// counter.js
export let count = 0
export function increment(){
    count++
}
```

```js
// main.js
import { count, increment } from './counter.js'
console.log(count)  // 0을 출력
increment()
console.log(count)  // 1을 출력
count++             // TypeError
```

- 사용자 코드의 직접적인 제어 밖에 있는 바인딩 값은 그것이 원래 존재하던 모듈(live binding)에서 바뀌지 않는 한, 원래 값에 대한 바인딩이 불가(read-only binding)하다는 것이다.
- CommonJS와는 다르며, CommonJS는 require 될 때 exports 객체 전체가 얕은 복사를 진행한다.

### 순환 종속성 분석

- [4장](./04.md)에서 보았던 순환 종속성을 ESM으로 바꾸면 서로 완전한 내용을 갖는 걸 확인할 수 있다. (loaded: true)

#### 1단계:파싱

- 파싱 단계에서 진입점(main.js)부터 코드 탐색을 시작한다.
- import 구문만 찾아서 트리 구조와 같이 종속성 그래프의 외관을 만든다.
- 순환 종속성 그래프의 깊이 우선 방문이 끝나면 선형적인 모듈들의 모습을 갖게 된다.

#### 2단계:인스턴스화

- 이전 단계에서 얻어진 트리 구조를 따라 메모리에 익스포트된 이름의 맵을 만든다.
    - 인터프리터는 b.js에서 main.js로 이동하며 익스포트하는 것을 포착한다.
- 그리고 임포트를 하는 모듈에게 익스포트된 이름의 링크를 전달한다.
- 이 단계에선 아직 모든 값이 인스턴스화 되진 않았다. 참조만 연결한다.

#### 3단계:평가

- 모든 파일의 모든 코드가 실행된다. 실행 순서는 후위 깊이 우선 탐색으로 거꾸로 올라간다.
    - 즉 main.js가 제일 마지막에 실행된다.

-----
[HOME](./index.md)
