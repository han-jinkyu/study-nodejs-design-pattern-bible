# 6. ESM: ECMAScript 모듈

- ESM과 CommonJS 사이의 가장 큰 차이점은 ES 모듈이 static이란 점이다.
- 즉 임포트는 모든 모듈의 가장 상위 레벨과 제어 흐름 구문의 바깥쪽에 기술된다.

```
// 이렇게 사용하는 건 적합하지 않다
if (condition) {
    import module1 from 'module1'
} else {
    import module2 from 'module2'
}
```

- 정적 임포트는 사용하지 않는 코드 제거(tree shaking)와 같이 코드 최적화를 할 수 있게 종속성 트리의 정적 분석을 가능하게 해준다.

## 6.1 Node.js에서 ESM의 사용

- Node.js에선 모든 .js 파일이 CommonJS 문법을 기본으로 따른다고 생각한다.
- 따라서 ESM 문법은 인터프리터 에러를 낼 것이다.
- 다음과 같이 사용하면 해결할 수 있다.
    - 모듈 파일의 확장자를 .mjs로 한다.
    - 모듈과 가장 근접한 package.json의 type 필드에 module이라 쓴다.

## 6.2 exports와 imports 지정하기(named exports and imports)

- ESM은 export 키워드를 통해 모듈의 기능을 익스포트한다.
- ESM에서는 기본적으로 private이며 export한 개체만 공개된다.

## 6.3 export와 import 기본값 설정하기(Default exports and imports)

- CommonJS의 module.exports처럼 ESM에서는 default export를 사용할 수 있다.
- 모듈 개발자에게 단일 책임 원칙을 권장하고 깔끔한 하나의 인터페이스를 노출할 수 있다.
- 내부적으로는 default라는 이름으로 익스포트되는 것과 동일하다.

## 6.4 혼합된 export(mixed exports)

- export와 default export를 혼합하여 사용할 수 있다.

```js
export default function log(message) {
    console.log(message)
}

export function info(message) {
    log(`info: ${message}`)
}
```

```js
import mylog, { info } from './logger.js'
```

- default export와 export의 차이점은 다음과 같다.
    - 이름을 가진 export는 명확하다. IDE로 하여금 추론할 수 있게 해준다.
    - default export는 모듈에서 가장 핵심적인 한 가지 기능과 연결하는 편리한 방법이다.
    - default export는 특정 상황에서 tree shaking을 어렵게 만든다.
- 명확한 하나의 기능을 사용할 땐 default export, 아닐 땐 export를 사용하길 권장한다.

## 6.5 모듈 식별자

- 모듈 식별자는 import 구문에서 우리가 적재하고 싶은 모듈의 경로를 명시할 때 쓰이는 값이다.
- 경로를 명시하는 방법은 아래와 같다.
    - 상대적 식별자(Relative): `./logger.js` 같은 방식
    - 절대 식별자(Absolute): `file://opt/nodejs/config.js` 같이 직접적인 경로. 이 방법은 ESM에만 해당하여, `/`, `//`로 시작하면 동작하지 않는다.
    - 노출 식별자(Bare): `node_modules` 폴더에서 사용 가능하고 패키지 매니저를 통해 설치된 모듈 또는 Node.js 코어 모듈을 가리킨다.
    - 심층 임포트 식별자(Deep import): `node_modules`에 있는 패키지의 경로.

-----
[HOME](./index.md)
