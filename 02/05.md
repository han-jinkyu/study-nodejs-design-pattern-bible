# 5. 모듈 정의 패턴

## 5.1 exports 지정하기(Named exports)

- public API를 공개하는 가장 기본적인 방법은 exports에 할당하는 것이다.
- 외부에 공개된 객체는 일련의 관련 기능에 대한 컨테이너 또는 네임스페이스가 된다.
- Node.js 코어 모듈 대부분은 이 패턴을 사용한다.
- CommonJS 명세엔 exports 변수만 사용하도록 한다.

## 5.2 함수 내보내기

- 가장 일반적인 모듈 정의 패턴 중 하나는 module.exports 변수 전체를 함수로 재할당하는 것이다.
- 이 방법은 서브스택(substack) 패턴으로 알려져있다.
- 장점으론 모듈에 대한 명확한 진입점을 제공하여 이해와 사용을 단순화할 수 있다는 점이다.

```js
// logger.js
module.exports = (message) => {
    console.log(`info: ${message}`)
}
```

- 다음은 익스포트된 함수를 네임스페이스로 사용하여 확장하는 방법이다.

```js
module.exports.verbose = (message) => {
    console.log(`verbose: ${message}`)
}
```

```js
// main.js
const logger = require('./logger')
logger('This is an informational message')
logger.verbose('This is a verbose message')
```

- Node.js의 모듈성은 SRP를 지킬 것을 강권한다.
- 모든 모듈은 단일 기능에 대한 책임을 지고, 책임은 모듈에 의해 완전히 캡슐화되어야 한다.

## 5.3 클래스 내보내기

- 이 패턴을 통해 사용자에게 생성자로 인스턴스를 새로 생성하게 할 수 있다.
- 또한 프로토타입을 확장하고 새로운 클래스를 만들 수 있는 기능을 제공한다.

```js
class Logger {
    constructor(name) {
        this.name = name
    }

    log(message) {
        console.log(`[${this.name}] ${message}`)
    }

    info(message) {
        this.log(`info: ${message}`)
    }

    verbose(message) {
        this.log(`verbose: ${message}`)
    }
}

module.exports = Logger
```

```js
// main.js
const Logger = require('./logger')
const dbLogger = new Logger('DB')
dbLogger.info('This is an informational message')
const accessLogger = new Logger('ACCESS')
accessLogger.verbose('This is a verbose message')
```

- 서브스택 패턴과 비교하면 더 많은 모듈의 내부를 노출하게 된다.
- 다른 한편으론 기능 확장에 있어 훨씬 더 강력할 수 있다.

## 5.4 인스턴스 내보내기

- require()의 캐싱 매커니즘을 이용해, 상태 저장 인스턴스를 쉽게 정의할 수 있다.

```js
// logger.js
class Logger {
    constructor(name) {
        this.count = 0
        this.name = name
    }

    log(message) {
        this.count++
        console.log(`[${this.name}] ${message}`)
    }
}
module.exports = new Logger('DEFAULT')
```

```js
// main.js
const logger = require('./logger')
logger.log('This is an informational message')
```

- 싱글톤을 만드는 것과 비슷하지만, 전체 애플리케이션에서 인스턴스의 고유성을 보장하진 못한다.
    - 해결(resolving) 알고리즘을 보면 종속성 트리 내에 모듈이 여러 번 생성될 수 있다.
- 또한 생성자가 새로운 인스턴스를 만들지 못하게 막지는 않았기에 새로 생성할 수도 있다.

## 5.5 다른 모듈 또는 전역 범위(global scope) 수정

- 모듈이 전역 범위의 다른 모듈이나 객체를 수정할 수 있는데, 이를 몽키 패치(monkey patching)라 한다.

```js
// patcher.js
require('./logger').customMessage = function () {
    console.log('This is a new functionality')
}
```

```js
// main.js
require('./patcher')
const logger = require('./logger')
logger.customMessage()
```

- 이 기법은 부작용이 존재하므로 신중하게 사용해야 한다.

-----
[HOME](./index.md)
