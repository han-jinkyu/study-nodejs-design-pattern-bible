# 2. 관찰자 패턴

- 관찰자 패턴은 상태 변화가 일어날 때 관찰자에서 통지할 수 있는 객체를 정의하는 것이다.
- 콜백 패턴은 오직 하나의 리스너에게 결과를 전달하는 반편, 관찰자 패턴은 주체가 여러 관찰자에게 통지할 수 있다는 점이 있다.

## 2.1 EventEmitter 클래스

- 관찰자 패턴은 이미 코어에 내장되어 있으며, EventEmitter 클래스를 통해 사용 가능하다.

```js
import { EventEmitter } from  'events'
const emitter = new EventEmitter()
```

- EventEmitter의 필수 메서드는 다음과 같다.
    - on(event, listenter): 주어진 이벤트 유형에 대해 새로운 리스너를 등록한다.
    - once(event, listener): 첫 이벤트가 전달된 후 제거되는 새로운 리스너를 등록한다.
    - emit(event, args...): 새 이벤트를 생성하고 리스너에게 전달한 추가 인자를 제공한다.
    - removeListener(event, listener): 지정된 이벤트 유형에 대한 리스너를 제거한다.
- 모든 메서드는 chaining이 가능하도록 EventEmitter 인스턴스를 반환한다.
- 첫 번째 인자가 꼭 에러일 필요는 없다.

## 2.2 EventEmitter 생성 및 사용

- 다음 코드는 EventEmitter를 사용해 파일 목록에서 특정 패턴이 발견되면 실시간으로 구독자에게 통지하는 함수다.

```js
import { EventEmitter } from 'events'
import { readFile } from 'fs'

function findRegex(files, regex) {
    const emitter = new EventEmitter()
    for (const file of files) {
        readFile(file, 'utf8', (err, content) => {
            if (err) {
                return emitter.emit('error', err)
            }

            emitter.emit('fileread', file)
            const match = content.match(regex)
            if (match) {
                match.forEach(elem => emitter.emit('found', file, elem))
            }
        })
    }
    return emitter
}
```

- 위 함수는 3가지 이벤트를 발생시키는 EventEmitter 인스턴스를 반환한다.
    - fileread, 파일을 읽을 때
    - found, 일치하는 항목이 발견되었을 때
    - error, 파일을 읽는 동안 에러가 발생하였을 때

```js
findRegex(
    ['fileA.txt', 'fileB.json'],
    /hello \w+/g
)
    .on('fileread', file => console.log(`${file} was read`))
    .on('found', (file, match) => console.log(`Matched "${match}" in ${file}`))
    .on('error', err => console.error(`Error emitted ${err.message}`))
```

## 2.3 오류 전파

- EventEmitter는 에러가 발생할 때 throw하지 못하고 error 이벤트를 발생시킨다.

## 2.4 관찰 가능한 객체 만들기

- EventEmitter 자체로 사용하는 경우는 별로 많지 않고, 다른 클래스의 확장이 일반적이다.

```js
import { EventEmitter } from 'events'
import { readFile } from 'fs'

class FindRegex extends EventEmitter {
    constructor(regex) {
        super()
        this.regex = regex
        this.files = []
    }

    addFile(file) {
        this.files.push(file)
        return this
    }

    find() {
        for (const file of this.files) {
            readFile(file, 'utf8', (err, content) => {
                if (err) {
                    return this.emit('error', err)
                }

                this.emit('fileread', file)

                const match = content.match(this.regex)
                if (match) {
                    match.forEach(elem => this.emit('found', file, elem))
                }
            })
        }
        return this
    }
}
```

- 내부 구성을 초기화하기 위해 constructor 내부에 `super()`를 써야 한다.

```js
const findRegexInstance = new FindRegex(/hello \w+/)
findRegexInstance
    .addFile('fileA.txt')
    .addFile('fileB.json')
    .find()
    .on('found', (file, match) => console.log(`Matched "${match}" in file ${file}`))
    .on('error', err => console.error(`Error emitted ${err.message}`))
```

- 위와 같은 패턴이 일반적이며, HTTP 모듈에서는 Server 객체가 있다.
    - request, connection, closed 이벤트를 생성한다.

## 2.5 EventEmitter와 메모리 누수

- 필요하지 않을 땐 구독 해지를 하는 것이 중요하다.
- 구독 해지는 메모리 누수를 예방하고 더 이상 사용하지 않는 객체의 메모리 점유를 풀어준다.

```js
// 메모리 누수 예
const thisTakesMemory = 'A big string...'
const listener = () => {
    console.log(thisTakesMemory)
}
emitter.on('an_event', listener)
```

- EventEmitter::removeListener() 메서드로 리스너를 해제할 수 있다.
- 리스너 수가 특정 개수(기본 10개)를 초과하면 경고하기도 한다.
- setMaxListeners()를 이용하여 늘릴 수도 있다.

## 2.6 동기 및 비동기 이벤트

- 동일한 EventEmitter에서 두 가지 접근 방식(동기, 비동기)을 섞어선 안 된다.
- 동기와 비동기 이벤트를 발생시키는 주된 차이점은 리스너 등록 방법에 있다.
- FindRegex() 클래스는 find() 호출 이후 비동기적으로 이벤트를 발생시킨다.
    - 따라서 이벤트가 사라질 염려 없이 find() 이후 리스너를 등록할 수 있다.
- 반면 동기적으로 이벤트를 발생시킨다면, 모든 리스너를 작업 실행 전에 등록해야 한다.

```js
// FindRegex::find()를 동기적으로 수정하기
find() {
    for (const file of this.files) {
        let content
        try {
            content = readFileSync(file, 'utf8')
        } catch (err) {
            this.emit('error', err)
        }

        this.emit('fileread', file)
        const match = content.match(this.regex)
        if (match) {
            match.forEach(elem => this.emit('found', file, elem))
        }
    }
    return this
}
```

```js
// find() 작업을 실행하기 전에 등록 && 실행 후에 등록
const findRegexInstance = new FindRegex(/hello \w+/)
findRegexInstance
    .addFile('fileA.txt')
    .addFile('fileB.json')
    // 리스너가 호출됨
    .on('found', (file, match) => console.log(`[Before] Matched "${match}" in file ${file}`))
    .find()
    // 리스너가 호출 안 됨
    .on('found', (file, match) => console.log(`[After] Matched "${match}" in file ${file}`))
```

- EventEmitter는 본래 비동기 이벤트를 다루는 것을 근본으로 한다.
- 동기적으로 발생하는 이벤트는 EventEmitter가 필요하지 않다는 신호다.

## 2.7 EventEmitter vs 콜백

- 비동기식 API를 정의할 때 공통적 딜레마는 EventEmitter를 사용할지, 콜백을 사용할지 결정하는 것이다.
- 결과가 비동기적으로 반환될 땐 콜백, 발생한 사건과 연결될 땐 이벤트다.

```js
import { EventEmitter } from 'events'

function helloEvents() {
    const eventEmitter = new EventEmitter()
    setTimeout(() => eventEmitter.emit('complete', 'hello world'), 100)
    return eventEmitter
}
function helloCallback(cb) {
    setTimeout(() => cb(null, 'hello world'), 100)
}

helloEvents().on('complete', message => console.log(message))
helloCallback((err, message) => console.log(message))
```

- 어떤 스타일을 선택할지에 대한 힌트가 있다.
    - 콜백은 여러 유형의 결과를 전달하는 덴 제한이 있다.
    - EventEmitter는 같은 이벤트가 여러 번 발생하거나 아예 발생하지 않을 수도 있는 경우에 사용하는 것이 좋다.
    - 콜백을 사용하는 API는 오직 특정한 콜백 하나만을 호출할 수 있다. 이벤트는 여러 리스너를 등록할 수 있다.

-----
[HOME](./index.md)
