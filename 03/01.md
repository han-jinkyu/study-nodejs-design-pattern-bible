# 1. 콜백 패턴

- 비동기식 프로그래밍은 일부 자업을 백그라운드 작업으로 실행할 수 있다.
- 비동기 작업이 끝나면 통지를 받아 다음 작업을 이어나간다.
- Node.js에서 작업 완료를 통지 받는 가장 기본적인 메커니즘은 **콜백**이다.
- 콜백은 다른 모든 비동기 메커니즘을 기초로 하는 하는 것들 중 가장 기본적인 구성요소다.
- 콜백은 리액터 패턴의 핸들러를 구현한 것이다.
- 작업의 결과를 전달하기 위해 호출되는 함수며, 비동기 작업에 필요하다.
- JavaScript는 콜백에 이상적이다. 함수가 일급 클래스 객체이기 때문이다.
- 또한 클로저(closure)를 사용하여 실제로 함수의 환경을 참조할 수 있다.

## 1.1 연속 전달 방식

- 콜백은 다른 함수에 인자로 전달되는 함수이며, 작업이 완료되면 작업 결과를 가지고 호출한다.
- 함수형 프로그래밍에서 이런 식의 결과 전달 방식을 **연속 전달 방식(CPS)**이라 한다.

### 동기식 연속 전달 방식

```js
// 직접 스타일(direct style)
function add(a, b) {
    return a + b
}

// CPS 함수
function addCps(a, b, callback) {
    callback(a + b)
}
```

```js
console.log('before')
addCps(1, 2, result => console.log(`Result: ${result}`))
console.log('after')

// before
// Result: 3
// after
```

### 비동기 연속 전달 방식

- `addCps()` 함수가 비동기인 경우...

```js
function additionAsync(a, b, callback) {
    setTimeout(() => callback(a + b), 100)
}
```

```js
console.log('before')
additionAsync(1, 2, result => console.log(`Result: ${result}`))
console.log('after')

// before
// after
// Result: 3
```

- 비동기 함수는 제어를 즉시 반환하고 결과는 이벤트 루프의 다음 사이클에서 핸들러(콜백)로 전달된다.

### 비 연속 전달(Non-CPS) 콜백

- 콜백 인자가 있다고 하여 항상 비동기식이거나 CPS를 사용하는 것은 아니다.

```js
const result = [1, 5, 7].map(element => element - 1)
console.log(result)     // [0, 4, 6]
```

- 위 경우엔 콜백을 연산할 때만 사용한다.
- 연속 전달 방식과 비 연속 전달 방식 사이엔 문법적 차이가 없으므로, API 문서에 분명히 명시된다.

-----
[HOME](./index.md)
