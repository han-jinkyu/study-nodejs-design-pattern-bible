# 1. 콜백 패턴

- 비동기식 프로그래밍은 일부 자업을 백그라운드 작업으로 실행할 수 있다.
- 비동기 작업이 끝나면 통지를 받아 다음 작업을 이어나간다.
- Node.js에서 작업 완료를 통지 받는 가장 기본적인 메커니즘은 **콜백**이다.
- 콜백은 다른 모든 비동기 메커니즘을 기초로 하는 하는 것들 중 가장 기본적인 구성요소다.
- 콜백은 리액터 패턴의 핸들러를 구현한 것이다.
- 작업의 결과를 전달하기 위해 호출되는 함수며, 비동기 작업에 필요하다.
- JavaScript는 콜백에 이상적이다. 함수가 일급 클래스 객체이기 때문이다.
- 또한 클로저(closure)를 사용하여 실제로 함수의 환경을 참조할 수 있다.

## 1.1 연속 전달 방식

- 콜백은 다른 함수에 인자로 전달되는 함수이며, 작업이 완료되면 작업 결과를 가지고 호출한다.
- 함수형 프로그래밍에서 이런 식의 결과 전달 방식을 **연속 전달 방식(CPS)**이라 한다.

### 동기식 연속 전달 방식

```js
// 직접 스타일(direct style)
function add(a, b) {
    return a + b
}

// CPS 함수
function addCps(a, b, callback) {
    callback(a + b)
}
```

```js
console.log('before')
addCps(1, 2, result => console.log(`Result: ${result}`))
console.log('after')

// before
// Result: 3
// after
```

### 비동기 연속 전달 방식

- `addCps()` 함수가 비동기인 경우...

```js
function additionAsync(a, b, callback) {
    setTimeout(() => callback(a + b), 100)
}
```

```js
console.log('before')
additionAsync(1, 2, result => console.log(`Result: ${result}`))
console.log('after')

// before
// after
// Result: 3
```

- 비동기 함수는 제어를 즉시 반환하고 결과는 이벤트 루프의 다음 사이클에서 핸들러(콜백)로 전달된다.

### 비 연속 전달(Non-CPS) 콜백

- 콜백 인자가 있다고 하여 항상 비동기식이거나 CPS를 사용하는 것은 아니다.

```js
const result = [1, 5, 7].map(element => element - 1)
console.log(result)     // [0, 4, 6]
```

- 위 경우엔 콜백을 연산할 때만 사용한다.
- 연속 전달 방식과 비 연속 전달 방식 사이엔 문법적 차이가 없으므로, API 문서에 분명히 명시된다.

## 1.2 동기? 비동기?

### 예측할 수 없는 함수

- 가장 위험한 상황 중 하나는 특정 조건에선 동기적으로, 특정 조건에선 비동기적으로 움직이는 것이다.

```js
import { readFile } from 'fs'

const cache = new Map()

function inconsistentRead(filename, cb) {
    if (cache.has(filename)) {
        cb(cache.get(filename))
    } else {
        // 비동기 함수
        readFile(filename, 'utf8', (err, data) => {
            cache.set(filename, data)
            cb(data)
        })
    }
}
```

### Zalgo를 풀어놓다

- 앞서 얘기한 예측할 수 없는 함수를 사용하면 애플리케이션이 쉽게 손상될 수 있다.

```js
function createFileReader(filename) {
    const listners = []
    inconsistentRead(filename, value => {
        listners.forEach(listener => listener(value))
    })

    return {
        onDataReady: listener => listeners.push(listener)
    }
}
```

- 위 함수를 활용한 `createFileReader()` 함수를 사용해본다.

```js
const reader1 = createFileReader('data.txt')
reader1.onDataReady(data => {
    console.log(`First call data: ${data}`)

    // 시간이 지난 후 같은 파일을 읽는다
    const reader2 = createFileReader('data.txt')
    reader2.onDataReady(data => {
        console.log(`Second call data: ${data}`)
    })
})
```

- 위 코드는 다음과 같은 결과를 출력한다.

```
First call data: some data
```

- 두 번째 콜백이 호출되지 않는데 이유는 다음과 같다.
    - reader1이 생성되는 동안 캐시된 결과가 없어서 비동기적으로 동작한다.
    - reader2는 요청된 파일에 대한 캐시가 이미 존재하는 이벤트 루프의 사이클에서 생성된다.
    - reader2의 모든 리스너가 동기적으로 호출된다.
    - 하지만 리스너를 reader2가 생성되고 등록하기 때문에 호출되지 않는다.
- 이런 버그는 재현하기 어렵다.
- Node.js 프로젝트 리더인 Schlueter는 이를 Zalgo를 풀어놓는 것에 비유했다.
    - Zalgo: 세계의 광기, 죽음, 파괴를 일으킨다고 하는 불길한 존재에 대한 전설

### 동기 API의 사용

- 앞선 사례에서 나온 교훈은 API의 동기/비동기 특성을 명확하게 정의하는 것이 필수적이란 것이다.
- inconsistentRead() 함수를 제대로 수정하는 방법 중 하나는 완전히 동기화하는 것이다.

```js
import { readFile } from 'fs'

const cache = new Map()

function inconsistentRead(filename) {
    if (cache.has(filename)) {
        return cache.get(filename)
    } else {
        // 비동기 함수
        const data = readFileSync(filename, 'utf8')
        cache.set(filename, data)
        return data
    }
}
```

- 비동기 API 대신 동기 API를 사용하면 몇 가지 주의해야 된다.
    - 특정 기능에 대한 동기식 API를 항상 사용할 수 있는 건 아니다.
    - 이벤트 루프를 블록하므로 속도를 떨어뜨린다.
- Node.js에선 동기 I/O를 권장하진 않는다. 하지만 쉽고 효율적인 해결이 되기도 한다.

### 지연 실행(deferred execution)으로 비동시성 보장

- 동기 콜백 호출이 가까운 미래에 실행되도록 예약하여 비동기적으로 해결할 수 있다.
- process.nextTick()을 사용하여 현재 진행 중인 작업의 완료 시점을 뒤로 지연시킨다.

```js
import { readFile } from 'fs'

const cache = new Map()

function consistentReadAsync(filename, callback) {
    if (cache.has(filename)) {
        // 지연된 콜백 호출
        process.nextTick(() => callback(cache.get(filename)))
    } else {
        // 비동기 함수
        readFileSync(filename, 'utf8', (err, data) => {
            cache.set(filename, data)
            callback(data)
        })
    }
}
```

- 또 다른 API는 setImmediate()다.
- process.nextTick()으로 지연된 콜백은 **마이크로 태스트**이며, 현재 작업이 완료된 후 바로 실행되고 다른 I/O 이벤트가 발생하기 전에 실행된다.
- setImmediate()는 이미 큐에 있는 I/O 이벤드의 뒤에 대기한다.

-----
[HOME](./index.md)
